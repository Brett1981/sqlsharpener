<#@ template debug="false" hostspecific="false" language="C#"  #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ parameter name="outputNamespace" type="System.String" #>
<#@ parameter name="connectionStringVariableName" type="System.String" #>
<#@ parameter name="procedurePrefix" type="System.String" #>
<#@ parameter name="sqlPaths" type="System.Collections.Generic.List<string>" #>
<#
  /// This creates a pre-compiled template that can be called from
  /// within a project to generate C# wrappers for stored procedures.

  var helper = new SqlSharpenerHelper();
  var meta = new MetaBuilder(sqlPaths.ToArray());
  meta.ProcedurePrefix = procedurePrefix ?? "";

/////////////////Begin Template//////////////////
 #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by SqlSharpener.
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace <#=helper.GetNamespace(outputNamespace)#>
{
	using System;
	using System.IO;
	using System.Data;
	using System.Data.SqlClient;
	using System.Configuration;
	using System.Collections.Generic;

	/// <summary>
	/// Interface of the wrapper class for calling stored procedures. 
	/// </summary>
	public partial interface IStoredProcedures
	{
<#foreach(var proc in meta.Procedures){ #>
		<#=helper.GetReturnType(proc)#> <#=proc.Name#>( <#=helper.GetMethodParamList(proc)#> );
<# } #>
	}

	/// <summary>
	/// Wrapper class for calling stored procedures. 
	/// </summary>
	public partial class StoredProcedures : IStoredProcedures
	{
<#foreach(var proc in meta.Procedures){ #>
		/// <summary>
		/// Calls the "<#=proc.RawName#>" stored procedure
		/// </summary>
		public <#=helper.GetReturnType(proc)#> <#=proc.Name#>( <#=helper.GetMethodParamList(proc)#> )
		{
			On<#=proc.Name#>Begin();
			<#=helper.GetReturnVariable(proc)#>
			var connectionString = ConfigurationManager.ConnectionStrings["<#=helper.GetConnStrVar(connectionStringVariableName)#>"].ConnectionString;
			using(var conn = new SqlConnection(connectionString))
			{
				conn.Open();
				using (var cmd = conn.CreateCommand())
				{
					cmd.CommandType = CommandType.StoredProcedure;
					cmd.CommandText = "<#=proc.RawName#>";
<#=helper.GetSqlParamList(proc, 5)#>
<#=helper.GetExecuteStatement(proc, 5)#>
				}
				conn.Close();
			}
			On<#=proc.Name#>End();
			return result;
		}

		partial void On<#=proc.Name#>Begin();
		partial void On<#=proc.Name#>End(<#=helper.GetReturnType(proc)#> result);

<# } #>

		/// <summary>
		/// Helper function to get the bytes out of varbinary columns
		/// </summary>
		private byte[] GetBytes(IDataReader reader, int ordinal)
		{
			MemoryStream ms = new MemoryStream();
			BinaryWriter writer = new BinaryWriter(ms);
			byte[] buffer = new byte[1024];
			long blobSize = reader.GetBytes(ordinal, 0, null, 0, 0);
			long currPos = 0;
			while (currPos < blobSize) {
				currPos += reader.GetBytes(ordinal, currPos, buffer, 0, 1024);
				writer.Write(buffer);
				writer.Flush();
			}
			writer.Close();
			return ms.ToArray();
		}
	}

<#foreach(var proc in meta.Procedures){ #>
<#=helper.GetDtoObject(proc, 1)#>
<# } #>
}
